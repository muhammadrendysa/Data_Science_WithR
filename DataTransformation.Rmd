---
title: "Untitled"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 5.1 Pendahuluan

Visualisasi adalah alat yang penting untuk menghasilkan wawasan, tetapi jarang sekali Anda mendapatkan data dalam bentuk yang tepat seperti yang Anda butuhkan. Sering kali Anda perlu membuat beberapa variabel atau ringkasan baru, atau mungkin Anda hanya ingin mengganti nama variabel atau menyusun ulang pengamatan untuk membuat data lebih mudah digunakan. Anda akan belajar bagaimana melakukan semua itu (dan banyak lagi!) dalam bab ini, yang akan mengajarkan Anda bagaimana mengubah data Anda menggunakan paket dplyr dan set data baru pada penerbangan yang berangkat dari New York City pada tahun 2013.

### 5.1.1 Prasyarat

Pada bab ini kita akan fokus pada bagaimana menggunakan paket dplyr, anggota inti lain dari tidyverse. Kita akan mengilustrasikan ide-ide kunci dengan menggunakan data dari paket nycflights13, dan menggunakan ggplot2 untuk membantu kita memahami data.

```{r massage=FALSE, warning=FALSE}
library(nycflights13)
library(tidyverse)
data(flights)
```

Perhatikan baik-baik pesan konflik yang tercetak ketika Anda memuat tidyverse. Pesan ini memberitahu Anda bahwa dplyr menimpa beberapa fungsi di dalam basis R. Jika Anda ingin menggunakan versi dasar dari fungsi-fungsi ini setelah memuat dplyr, Anda harus menggunakan nama lengkapnya: stats::filter() dan stats::lag().

### 5.1.2 nycflights13

Untuk mengeksplorasi kata kerja manipulasi data dasar dari dplyr, kita akan menggunakan nycflights13::flights. Kerangka data ini berisi semua 336.776 penerbangan yang berangkat dari New York City pada tahun 2013. Data tersebut berasal dari Biro Statistik Transportasi AS, dan didokumentasikan dalam ?flights.

```{r}
head(flights)
```

Anda mungkin memperhatikan bahwa data frame ini mencetak sedikit berbeda dari data frame lain yang mungkin pernah Anda gunakan sebelumnya: data frame ini hanya menampilkan beberapa baris pertama dan semua kolom yang muat di satu layar. (Untuk melihat seluruh dataset, Anda dapat menjalankan View(flights) yang akan membuka dataset di penampil RStudio). Dataset ini dicetak secara berbeda karena berbentuk tibble. Tibble adalah bingkai data, tetapi sedikit diubah agar bekerja lebih baik di tidyverse. Untuk saat ini, Anda tidak perlu khawatir tentang perbedaannya; kita akan kembali ke tibble secara lebih rinci dalam pembahasan berikutnya.

Anda mungkin juga telah memperhatikan deretan tiga (atau empat) singkatan huruf di bawah nama kolom. Hal ini menjelaskan tipe dari setiap variabel:

-   int adalah singkatan dari bilangan bulat.

-   dbl adalah singkatan dari double, atau bilangan real.

-   chr adalah singkatan dari vektor karakter, atau string.

-   dttm adalah singkatan dari tanggal-waktu (tanggal + waktu).

Ada tiga jenis variabel umum lainnya yang tidak digunakan dalam kumpulan data ini, namun akan Anda temui nanti di dalam buku ini:

-   lgl adalah singkatan dari logical, vektor yang hanya berisi TRUE atau FALSE.

-   fctr adalah singkatan dari faktor, yang digunakan R untuk merepresentasikan variabel kategorikal dengan nilai yang tetap.

-   date adalah singkatan dari tanggal.

### 5.1.3 dasar-dasar dplyr

Pada bab ini Anda akan mempelajari lima fungsi utama dplyr yang memungkinkan Anda untuk menyelesaikan sebagian besar tantangan manipulasi data Anda:

-   Memilih observasi berdasarkan nilainya (filter()).

-   Menyusun ulang baris (arrange()).

-   Memilih variabel berdasarkan namanya (select()).

-   Membuat variabel baru dengan fungsi dari variabel yang sudah ada (mutate()).

-   Meringkas banyak nilai menjadi satu rangkuman (summarise()).

Semua fungsi ini dapat digunakan bersama dengan group_by() yang mengubah cakupan setiap fungsi dari yang tadinya beroperasi pada seluruh dataset menjadi beroperasi pada dataset per kelompok. Keenam fungsi ini menyediakan kata kerja untuk bahasa manipulasi data.

Semua kata kerja bekerja dengan cara yang sama:

-   Argumen pertama adalah kerangka data.

-   Argumen berikutnya menjelaskan apa yang harus dilakukan dengan data frame, menggunakan nama variabel (tanpa tanda kutip).

-   Hasilnya adalah sebuah bingkai data baru.

Bersama-sama, properti ini memudahkan untuk menggabungkan beberapa langkah sederhana untuk mencapai hasil yang kompleks. Mari kita pelajari dan lihat bagaimana cara kerja kata kerja ini.

## 5.2 Menyaring baris dengan filter()

filter() memungkinkan Anda untuk melakukan subset pengamatan berdasarkan nilainya. Argumen pertama adalah nama bingkai data. Argumen kedua dan selanjutnya adalah ekspresi yang menyaring bingkai data. Sebagai contoh, kita dapat memilih semua penerbangan pada tanggal 1 Januari dengan:

```{r}
head(filter(flights, month == 1, day == 1))
```

Ketika Anda menjalankan baris kode tersebut, dplyr mengeksekusi operasi penyaringan dan mengembalikan sebuah frame data baru. Fungsi-fungsi dplyr tidak pernah memodifikasi input mereka, jadi jika Anda ingin menyimpan hasilnya, Anda harus menggunakan operator penugasan, \<-:

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

R dapat mencetak hasilnya, atau menyimpannya ke dalam variabel. Jika Anda ingin melakukan keduanya, Anda dapat membungkus tugas dalam tanda kurung:

```{r}
(dec25 <- filter(flights, month == 12, day == 25)) %>% head()
```

### 5.2.1 Perbandingan

Untuk menggunakan pemfilteran secara efektif, Anda harus mengetahui cara memilih pengamatan yang Anda inginkan dengan menggunakan operator perbandingan. R menyediakan rangkaian standar: \>, \>=, \<, \<=, != (tidak sama), dan == (sama).

Ketika Anda mulai menggunakan R, kesalahan yang paling mudah dilakukan adalah menggunakan = dan bukannya == ketika menguji kesetaraan. Ketika hal ini terjadi, Anda akan mendapatkan sebuah kesalahan yang informatif:

```{r}
head(filter(flights, month == 1))
```

Ada masalah umum lain yang mungkin Anda temui ketika menggunakan ==: bilangan floating point. Hasil ini mungkin akan mengejutkan Anda!

```{r}
sqrt(2) ^ 2 == 2
```

```{r}
1 / 49 * 49 == 1
```

Komputer menggunakan aritmatika presisi terbatas (mereka jelas tidak dapat menyimpan jumlah digit yang tak terbatas!) jadi ingatlah bahwa setiap angka yang Anda lihat adalah sebuah perkiraan. Daripada mengandalkan ==, gunakanlah near():

```{r}
near(sqrt(2) ^ 2, 2)
```

```{r}
near(1 / 49 * 49, 1)
```

### 5.2.2 Operator logika

Beberapa argumen untuk filter() digabungkan dengan "and": setiap ekspresi harus bernilai benar agar sebuah baris disertakan dalam output. Untuk jenis kombinasi lainnya, Anda harus menggunakan operator Boolean sendiri: & adalah "dan", \| adalah "atau", dan ! adalah "tidak". Gambar 5.1 menunjukkan set lengkap operasi Boolean.

```{r, out.height= "400px", out.width= "400px"}
knitr::include_graphics("C:/Users/Repets/Downloads/transform-logical (1).png")
```

Kode berikut ini menemukan semua penerbangan yang berangkat pada bulan November atau Desember:

```{r}
head(filter(flights, month == 11 | month == 12))
```

Urutan operasi tidak bekerja seperti bahasa Inggris. Anda tidak dapat menulis filter(flights, month == (11 \| 12)), yang secara harfiah dapat diterjemahkan menjadi "menemukan semua penerbangan yang berangkat pada bulan November atau Desember". Sebaliknya, filter ini menemukan semua bulan yang sama dengan 11 \| 12, sebuah ekspresi yang dievaluasi menjadi TRUE. Dalam konteks numerik (seperti di sini), TRUE menjadi satu, jadi ini menemukan semua penerbangan di bulan Januari, bukan November atau Desember. Ini cukup membingungkan!

Cara singkat yang berguna untuk masalah ini adalah x %in% y. Ini akan memilih setiap baris di mana x adalah salah satu nilai di y. Kita dapat menggunakannya untuk menulis ulang kode di atas:

```{r}
nov_dec <- filter(flights, month %in% c(11, 12))
```

Terkadang Anda dapat menyederhanakan subset yang rumit dengan mengingat hukum De Morgan: !(x & y) sama dengan !x \| !y, dan !(x \| y) sama dengan !x & !y. Sebagai contoh, jika Anda ingin menemukan penerbangan yang tidak tertunda (pada saat kedatangan atau keberangkatan) lebih dari dua jam, Anda dapat menggunakan salah satu dari dua filter berikut:

```{r}
head(filter(flights, !(arr_delay > 120 | dep_delay > 120)))
head(filter(flights, arr_delay <= 120, dep_delay <= 120))
```

Selain & dan \|, R juga memiliki && dan \|\|. Jangan gunakan mereka di sini! Anda akan belajar kapan Anda harus menggunakannya dalam eksekusi bersyarat.

Kapanpun Anda mulai menggunakan ekspresi yang rumit dan banyak bagian dalam filter(), pertimbangkan untuk menjadikannya sebagai variabel eksplisit. Hal ini akan membuat Anda lebih mudah untuk memeriksa pekerjaan Anda. Anda akan belajar bagaimana membuat variabel baru segera.

### 5.2.3 Nilai yang hilang

Salah satu fitur penting dari R yang dapat membuat perbandingan menjadi rumit adalah nilai yang hilang, atau NA ("tidak tersedia"). NA mewakili nilai yang tidak diketahui sehingga nilai yang hilang bersifat "menular": hampir semua operasi yang melibatkan nilai yang tidak diketahui juga akan menjadi tidak diketahui.

```{r}
NA > 5
```

```{r}
10 == NA
```

```{r}
NA + 10
```

```{r}
NA / 2
```

Hasil yang paling membingungkan adalah yang satu ini:

```{r}
NA == NA
```

Paling mudah untuk memahami mengapa hal ini benar dengan sedikit lebih banyak konteks:

```{r}
# Biarkan x menjadi usia Mary. Kita tidak tahu berapa umurnya.
x <- NA

# Biarkan y menjadi usia John. Kita tidak tahu berapa usianya.
y <- NA

# Apakah John dan Mary seumuran?
x == y
```

Jika Anda ingin menentukan apakah sebuah nilai hilang, gunakan is.na():

```{r}
is.na(x)
```

filter() hanya menyertakan baris yang kondisinya TRUE; tidak termasuk nilai FALSE dan NA. Jika Anda ingin mempertahankan nilai yang hilang, tanyakan secara eksplisit:

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
```

```{r}
filter(df, is.na(x) | x > 1)
```

### 5.2.4 Latihan

1.  Temukan semua penerbangan yang

Mengalami keterlambatan kedatangan dua jam atau lebih

```{r}
head(filter(flights, arr_delay >= 120))
```

Terbang ke Houston (IAH atau HOU)

```{r}
head(filter(flights, dest %in% c("IAH", "HOU")))
```

Dioperasikan oleh United, American, atau Delta

```{r}
head(filter(flights, carrier %in% c("UA", "AA", "DL")))
```

Berangkat pada musim panas (Juli, Agustus, dan September)

```{r}
head(filter(flights, month %in% c(7, 8, 9)))
```

Tiba terlambat lebih dari dua jam, tetapi tidak berangkat terlambat

```{r}
head(filter(flights, arr_delay > 120, dep_delay == 0))
```

Tertunda setidaknya satu jam, tetapi lebih dari 30 menit dalam penerbangan

```{r}
head(filter(flights, dep_delay >= 60, air_time > 30))
```

Berangkat antara tengah malam dan pukul 6 pagi (inklusif)

```{r}
head(filter(flights, between(hour, 0, 6)))
```

2.  Pembantu pemfilteran dplyr lain yang berguna adalah between(). Apa fungsinya? Dapatkah Anda menggunakannya untuk menyederhanakan kode yang diperlukan untuk menjawab tantangan sebelumnya?

Fungsi **`between()`** dalam paket **`dplyr`** digunakan untuk melakukan pemfilteran berdasarkan rentang nilai pada suatu variabel. Fungsi ini membantu memilih baris yang memenuhi kondisi rentang tertentu.

Dalam konteks tantangan sebelumnya yang melibatkan pemfilteran penerbangan berdasarkan rentang nilai pada variabel tertentu, kita dapat menggunakan **`between()`** untuk menyederhanakan kode.

Misalnya, jika kita ingin memfilter penerbangan berdasarkan rentang nilai pada variabel 'hour', kita dapat menggunakan **`between()`** sebagai berikut:

```{r}
head(filter(flights, between(hour, 0, 6)))
```

3.  Berapa banyak penerbangan yang memiliki dep_time yang hilang? Variabel apa lagi yang hilang? Apa yang mungkin diwakili oleh baris-baris ini?

```{r}
missing_dep_time <- sum(is.na(flights$dep_time))

variable_missing <- colSums(is.na(flights))

print(missing_dep_time)
print(data.frame(variable_missing))
```

4.  Mengapa NA \^ 0 tidak hilang? Mengapa NA \| TRUE tidak hilang? Mengapa FALSE & NA tidak hilang? Dapatkah Anda mengetahui aturan umumnya? (NA \* 0 adalah contoh tandingan yang rumit!)

Mengapa NA \^ 0 tidak hilang? Ketika kita menggunakan operator pangkat (\^), R mengikuti aturan matematika bahwa nilai NA ditingkatkan ke kuasa apa pun akan tetap NA. Ini dikarenakan nilai yang hilang (NA) mengindikasikan ketidakpastian, dan hasil dari operasi matematika yang melibatkan ketidakpastian tetap menjadi ketidakpastian. Dalam kasus ini, NA \^ 0 dianggap sebagai nilai yang hilang (NA).

Mengapa NA \| TRUE tidak hilang? Operator logika OR (\|) mengikuti aturan bahwa jika salah satu operand adalah TRUE, hasilnya akan selalu TRUE. Dalam kasus ini, meskipun salah satu operandnya adalah nilai yang hilang (NA), karena terdapat nilai TRUE, hasilnya tetap TRUE.

Mengapa FALSE & NA tidak hilang? Operator logika AND (&) mengikuti aturan bahwa jika salah satu operand adalah FALSE, hasilnya akan selalu FALSE. Dalam kasus ini, meskipun salah satu operandnya adalah nilai yang hilang (NA), karena terdapat nilai FALSE, hasilnya tetap FALSE.

## 5.3 Mengatur baris dengan arrange()

arrange() bekerja mirip dengan filter() kecuali bahwa alih-alih memilih baris, ia mengubah urutannya. Dibutuhkan sebuah bingkai data dan sekumpulan nama kolom (atau ekspresi yang lebih rumit) untuk mengurutkannya. Jika Anda memberikan lebih dari satu nama kolom, setiap kolom tambahan akan digunakan untuk memutus hubungan nilai dari kolom-kolom sebelumnya:

```{r}
head(arrange(flights, year, month, day))
```

Gunakan desc() untuk mengurutkan ulang berdasarkan kolom dalam urutan menurun:

```{r}
head(arrange(flights, desc(dep_delay)))
```

Nilai yang hilang selalu diurutkan di bagian akhir:

```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, x)
```

```{r}
arrange(df, desc(x))
```

### 5.3.1 Latihan

1.  Bagaimana Anda dapat menggunakan arrange() untuk mengurutkan semua nilai yang hilang dari awal? (Petunjuk: gunakan is.na()).

```{r}
head(arrange(flights, desc(is.na(dep_delay))))
```

2.  Mengurutkan penerbangan untuk menemukan penerbangan yang paling banyak ditunda. Temukan penerbangan yang berangkat paling awal.

```{r}
penerbangan_ditunda_terbanyak <- arrange(flights, desc(dep_delay))
head(penerbangan_ditunda_terbanyak, 1)
```

```{r}
penerbangan_terawal <- arrange(flights, dep_time)

head(penerbangan_terawal, 1)
```

3.  Mengurutkan penerbangan untuk menemukan penerbangan tercepat (kecepatan tertinggi).

```{r}
penerbangan_tercepat <- arrange(flights, air_time)

head(penerbangan_tercepat, 1)
```

4.  Penerbangan mana yang menempuh jarak terjauh? Penerbangan mana yang menempuh perjalanan terpendek?


```{r}
penerbangan_jarak_terpendek <- arrange(flights, distance)
print(head(penerbangan_jarak_terpendek, 1))
```

## 5.4 Memilih kolom dengan select()

Tidak jarang kita mendapatkan kumpulan data dengan ratusan atau bahkan ribuan variabel. Dalam kasus ini, tantangan pertama yang sering dihadapi adalah mempersempit variabel yang benar-benar Anda minati. select() memungkinkan Anda untuk dengan cepat memperbesar subset yang berguna dengan menggunakan operasi berdasarkan nama-nama variabel.

select() tidak terlalu berguna pada data penerbangan karena kita hanya memiliki 19 variabel, tetapi Anda masih bisa mendapatkan gambaran umumnya:

```{r}
# Pilih kolom berdasarkan nama
head(select(flights, year, month, day))
```

```{r}
# Pilih semua kolom antara tahun dan hari (inklusif)
head(select(flights, year:day))
```

```{r}
# Pilih semua kolom kecuali yang dari tahun ke hari (inklusif)
head(select(flights, -(year:day)))
```

Ada beberapa fungsi pembantu yang dapat Anda gunakan dalam select():

-   starts_with("abc"): mencocokkan nama yang dimulai dengan "abc".

-   ends_with("xyz"): mencocokkan nama yang diakhiri dengan "xyz".

-   contains("ijk"): mencocokkan nama yang mengandung "ijk".

-   matches("(.)\\\\1"): memilih variabel yang cocok dengan ekspresi reguler. Fungsi ini cocok dengan variabel apa pun yang berisi karakter berulang. Anda akan mempelajari lebih lanjut tentang ekspresi reguler dalam string.

-   num_range("x", 1:3): mencocokkan x1, x2 dan x3.

Lihat ?select untuk detail lebih lanjut.

select() dapat digunakan untuk mengganti nama variabel, tetapi jarang berguna karena ia membuang semua variabel yang tidak disebutkan secara eksplisit. Sebagai gantinya, gunakan rename(), yang merupakan varian dari select() yang menyimpan semua variabel yang tidak disebutkan secara eksplisit:

```{r}
rename(flights, tail_num = tailnum) %>% head()
```

Pilihan lainnya adalah dengan menggunakan select() bersama dengan pembantu everything(). Ini berguna jika Anda memiliki beberapa variabel yang ingin Anda pindahkan ke awal bingkai data.

```{r}
select(flights, time_hour, air_time, everything()) %>% head()
```

### 5.4.1 Latihan

1.  Pikirkan sebanyak mungkin cara untuk memilih dep_time, dep_delay, arr_time, dan arr_delay dari penerbangan.

```{r}
head(select(flights, dep_time, dep_delay, arr_time, arr_delay))
```

```{r}
head(select(flights, starts_with("dep"), starts_with("arr")))
```

```{r}
head(select(flights, contains("dep_"), contains("arr_"), -contains("sched_")))
```

2.  Apa yang terjadi jika Anda menyertakan nama variabel beberapa kali dalam pemanggilan select()?

```{r}
head(select(flights, dep_delay, dep_time, dep_delay))
```

perilaku fungsi **`select()`** yang secara otomatis menghilangkan duplikasi kolom. Dalam pemanggilan **`select(flights, dep_delay, dep_time, dep_delay)`**, kolom dep_delay hanya akan muncul satu kali dalam hasil pemilihan kolom, dan tidak akan diulang.

2.  Apa yang dilakukan oleh fungsi any_of()? Mengapa fungsi ini dapat membantu dalam hubungannya dengan vektor ini?

```{r}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
```

```{r}
select(flights, one_of(vars)) %>% head()
```

Fungsi **`any_of()`** adalah salah satu fungsi yang disediakan oleh library **`dplyr`** dalam bahasa pemrograman R. Fungsi ini digunakan dalam konteks pemilihan kolom dengan tujuan memilih kolom-kolom yang diinginkan berdasarkan nama kolom yang terkandung dalam vektor atau daftar yang diberikan.

Dalam konteks yang diberikan, jika kita memiliki vektor **`vars`** yang berisi nama kolom seperti: **`"year"`**, **`"month"`**, **`"day"`**, **`"dep_delay"`**, dan **`"arr_delay"`**, kita dapat menggunakan fungsi **`any_of()`** untuk memilih kolom-kolom yang terkandung dalam vektor tersebut dari suatu dataset.

4.  Apakah hasil dari menjalankan kode berikut ini mengejutkan Anda? Bagaimana cara pembantu terpilih menangani kasus secara default? Bagaimana Anda dapat mengubah default tersebut?

```{r}
head(select(flights, contains("TIME")))
```

Tidak, hasil dari menjalankan kode **`head(select(flights, contains("TIME")))`** tidak mengejutkan. Kode tersebut akan menghasilkan subset dari dataset **`flights`** yang hanya terdiri dari kolom-kolom yang mengandung kata "TIME" dalam namanya, dan kemudian menampilkan 6 baris pertama dari subset tersebut menggunakan fungsi **`head()`**.

Dalam kasus ini, fungsi **`contains()`** digunakan untuk memilih kolom-kolom yang mengandung kata "TIME" dalam namanya. Jadi, hasilnya akan berupa subset dataset **`flights`** yang hanya berisi kolom-kolom yang memenuhi kriteria tersebut.

## 5.5 Menambahkan variabel baru dengan mutate()

Selain memilih kumpulan kolom yang sudah ada, sering kali berguna untuk menambahkan kolom baru yang merupakan fungsi dari kolom yang sudah ada. Itulah tugas dari mutate().

mutate() selalu menambahkan kolom baru di akhir dataset Anda, jadi kita akan mulai dengan membuat dataset yang lebih sempit agar kita dapat melihat variabel-variabel baru. Ingatlah bahwa ketika Anda berada di RStudio, cara termudah untuk melihat semua kolom adalah dengan menggunakan View().

```{r}
flights_sml <- select(flights, year:day, ends_with("delay"), distance, air_time)

head(mutate(flights_sml,
       gain = dep_delay - arr_delay,
       speed = distance / air_time * 60))
```

Perhatikan bahwa Anda dapat merujuk ke kolom yang baru saja Anda buat:

```{r}
head(mutate(flights, 
            gain = dep_delay - arr_delay,
            hours = air_time / 60,
            gain_per_hour = gain / hours))
```

### 5.5.1 Fungsi kreasi yang berguna

Ada banyak fungsi untuk membuat variabel baru yang dapat Anda gunakan dengan mutate(). Properti utamanya adalah bahwa fungsi tersebut harus berbentuk vektor: fungsi tersebut harus mengambil vektor nilai sebagai masukan, mengembalikan vektor dengan jumlah nilai yang sama sebagai keluaran. Tidak ada cara untuk membuat daftar semua fungsi yang mungkin Anda gunakan, tetapi berikut adalah beberapa pilihan fungsi yang sering digunakan:

-   Operator aritmatika: +, -, \*, /, \^. Semua ini adalah vektor, menggunakan apa yang disebut "aturan daur ulang". Jika salah satu parameter lebih pendek dari yang lain, maka secara otomatis akan diperpanjang menjadi panjang yang sama. Hal ini sangat berguna ketika salah satu argumennya berupa angka tunggal: air_time / 60, jam \* 60 + menit, dll.

-   Operator aritmatika juga berguna dalam hubungannya dengan fungsi agregat yang akan Anda pelajari nanti. Misalnya, x / sum(x) menghitung proporsi total, dan y - mean(y) menghitung selisih dari rata-rata.

-   Aritmatika modular: %/% (pembagian bilangan bulat) dan %% (sisa), di mana x == y \* (x %/% y) + (x %% y). Aritmatika modular adalah alat yang praktis karena memungkinkan Anda untuk memecah bilangan bulat menjadi beberapa bagian. Sebagai contoh, pada set data penerbangan, Anda dapat menghitung jam dan menit dari dep_time dengan:

```{r}
transmute(flights,
          dep_time,
          hour = dep_time %/% 100,
          minute = dep_time %% 100) %>% head()
```

-   Log: log(), log2(), log10(). Logaritma adalah transformasi yang sangat berguna untuk menangani data yang memiliki rentang dalam berbagai urutan. Mereka juga mengubah hubungan perkalian menjadi aditif, sebuah fitur yang akan kita bahas kembali dalam pemodelan.

Dengan catatan, saya sarankan untuk menggunakan log2() karena mudah untuk diinterpretasikan: selisih 1 pada skala log sama dengan penggandaan pada skala asli dan selisih -1 sama dengan separuh.

-   Offset: lead() dan lag() memungkinkan Anda untuk merujuk pada nilai terdepan atau tertinggal. Hal ini memungkinkan Anda untuk menghitung perbedaan yang sedang berjalan (contohnya x - lag(x)) atau menemukan kapan nilai berubah (x != lag(x)). Fungsi-fungsi ini sangat berguna dalam hubungannya dengan group_by(), yang akan Anda pelajari sebentar lagi.

```{r}
(x <- 1:10)
```

```{r}
lag(x)
```

```{r}
lead(x)
```

-   Agregat kumulatif dan bergulir: R menyediakan fungsi-fungsi untuk menjalankan penjumlahan, produk, min dan maks: cumsum(), cumprod(), cummin(), cummax(); dan dplyr menyediakan cummean() untuk cara kumulatif. Jika Anda membutuhkan agregat bergulir (yaitu jumlah yang dihitung melalui jendela bergulir), cobalah paket RcppRoll.

```{r}
x
```

```{r}
cumsum(x)
```

```{r}
cummean(x)
```

-   Perbandingan logika, \<, \<=, \>, \>=, !=, dan ==, yang telah Anda pelajari sebelumnya. Jika Anda melakukan urutan operasi logika yang kompleks, sering kali merupakan ide yang baik untuk menyimpan nilai sementara dalam variabel baru sehingga Anda dapat memeriksa apakah setiap langkah berjalan sesuai dengan yang diharapkan.

-   Pemeringkatan: ada beberapa fungsi pemeringkatan, tetapi Anda harus memulai dengan min_rank(). Fungsi ini melakukan jenis pemeringkatan yang paling umum (misal: 1, 2, 2, 4). Defaultnya memberikan nilai terkecil sebagai peringkat kecil; gunakan desc(x) untuk memberikan nilai terbesar sebagai peringkat terkecil.

```{r}
y <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
```

```{r}
min_rank(desc(y))
```

Jika min_rank() tidak melakukan apa yang Anda butuhkan, lihatlah varian-varian row_number(), dense_rank(), percent_rank(), cume_dist(), ntile(). Lihat halaman bantuan mereka untuk lebih jelasnya.

```{r}
row_number(y)
```

```{r}
dense_rank(y)
```

```{r}
percent_rank(y)
```

```{r}
cume_dist(y)
```

### 5.5.2 Latihan

1.  Saat ini dep_time dan sched_dep_time nyaman untuk dilihat, namun sulit untuk dihitung karena bukan angka yang berkelanjutan. Ubahlah menjadi representasi yang lebih nyaman dari jumlah menit sejak tengah malam.

```{r}
transmute(flights,
           dep_time,
           sched_dep_time,
           dep_time_minute = (dep_time %/% 100)*60 + (dep_time %% 100),
           sched_dep_time_minute = (sched_dep_time %/% 100)*60 + (sched_dep_time %% 100)) %>% head()
```

2.  Bandingkan air_time dengan arr_time - dep_time. Apa yang Anda harapkan untuk dilihat? Apa yang Anda lihat? Apa yang perlu Anda lakukan untuk memperbaikinya?

```{r}
data_time <- transmute(flights, air_time, diff_time = arr_time - dep_time)
head(data_time)
```

```{r}
#konversi diff_time
transmute(flights, air_time, diff_time = (((arr_time %/% 100)*60) + (arr_time %% 100)) - (((dep_time %/% 100)*60) + (dep_time %% 100)))
```

3.  Bandingkan dep_time, sched_dep_time, dan dep_delay. Bagaimana Anda mengharapkan ketiga angka tersebut berhubungan?

```{r}
dep_time_data <- transmute(flights, dep_time, sched_dep_time, dep_delay,
                           diff_time_minute = (((dep_time %/% 100)*60) + (dep_time %% 100) - (((sched_dep_time %/% 100)*60) + (sched_dep_time %% 100))))

head(dep_time_data)
```

4.  Cari 10 penerbangan yang paling sering mengalami keterlambatan dengan menggunakan fungsi pemeringkatan. Bagaimana Anda ingin menangani hubungan? Baca dengan seksama dokumentasi untuk min_rank().

```{r}
top_rank_delay <- flights %>%
  transmute(dep_delay, delay_rank = min_rank(dep_delay)) %>%
  arrange(desc(delay_rank))

head(top_rank_delay)
```

5.  Apa yang dihasilkan oleh 1:3 + 1:10? Mengapa?

```{r}
# mengembalikan kesalahan

1:3 + 1:10
```

```{r}
# jika menambahkan ke kelipatan:
1:5 + 1:10
```

6.  Fungsi trigonometri apa saja yang disediakan oleh R?

Diambil dari dokumentasi R: "Fungsi-fungsi ini memberikan fungsi trigonometri yang jelas. Fungsi-fungsi ini masing-masing menghitung kosinus, sinus, tangen, busur-kosinus, busur-sinus, busur-tangen, dan busur-tangen dua argumen."

-   sin(x): Menghitung sinus dari sudut x (dalam radian).
-   cos(x): Menghitung kosinus dari sudut x (dalam radian).
-   tan(x): Menghitung tangen dari sudut x (dalam radian).
-   asin(x): Menghitung invers sinus dari x. Hasilnya dalam radian antara -π/2 hingga π/2.
-   acos(x): Menghitung invers kosinus dari x. Hasilnya dalam radian antara 0 hingga π.
-   atan(x): Menghitung invers tangen dari x. Hasilnya dalam radian antara -π/2 hingga π/2.
-   atan2(y, x): Menghitung invers tangen dari y/x dengan mempertimbangkan kuadran sudut. Hasilnya dalam radian antara -π hingga π.
-   sinh(x): Menghitung sinus hiperbolik dari x (dalam radian).
-   cosh(x): Menghitung kosinus hiperbolik dari x (dalam radian).
-   tanh(x): Menghitung tangen hiperbolik dari x (dalam radian).
-   acosh(x): Menghitung invers kosinus hiperbolik dari x. Hasilnya dalam radian.
-   asinh(x): Menghitung invers sinus hiperbolik dari x. Hasilnya dalam radian.
-   atanh(x): Menghitung invers tangen hiperbolik dari x. Hasilnya dalam radian.

## 5.6 Rangkuman yang dikelompokkan dengan summarise()

Kata kerja kunci terakhir adalah summarise(). Fungsi ini menciutkan bingkai data menjadi satu baris:

```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

(Kita akan kembali lagi pada apa arti dari na.rm = TRUE dalam waktu dekat).

summarize() tidak terlalu berguna kecuali jika kita memasangkannya dengan group_by(). Ini mengubah unit analisis dari kumpulan data lengkap menjadi kelompok-kelompok individual. Kemudian, ketika Anda menggunakan kata kerja dplyr pada kumpulan data yang telah dikelompokkan, kata kerja tersebut akan secara otomatis diterapkan "berdasarkan kelompok". Sebagai contoh, jika kita menerapkan kode yang sama persis pada data frame yang dikelompokkan berdasarkan tanggal, kita akan mendapatkan rata-rata penundaan per tanggal:

```{r}
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

Bersama-sama group_by() dan summarize() menyediakan salah satu alat yang paling sering Anda gunakan ketika bekerja dengan dplyr: ringkasan yang dikelompokkan. Namun sebelum kita melangkah lebih jauh dengan ini, kita perlu memperkenalkan sebuah ide baru yang hebat: pipa.

### 5.6.1 Menggabungkan beberapa operasi dengan pipa

Bayangkan bahwa kita ingin mengeksplorasi hubungan antara jarak dan rata-rata penundaan untuk setiap lokasi. Dengan menggunakan apa yang Anda ketahui tentang dplyr, Anda dapat menulis kode seperti ini:

```{r}
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
                   count = n(),
                   dist = mean(distance, na.rm = TRUE),
                   delay = mean(arr_delay, na.rm = TRUE))

delay <- filter(delay, count > 20, dest != "HNL")

ggplot(data = delay, mapping = aes(x = dist, y = delay))+
  geom_point(mapping = aes(size = count), alpha = 1/3)+
  geom_smooth(se = FALSE)
```

Ada tiga langkah untuk menyiapkan data ini:

-   Kelompokkan penerbangan berdasarkan tujuan.

-   Rangkum untuk menghitung jarak, rata-rata penundaan, dan jumlah penerbangan.

-   Filter untuk menghilangkan titik-titik bising dan bandara Honolulu, yang jaraknya hampir dua kali lipat dari bandara terdekat.

Kode ini sedikit membuat frustasi untuk ditulis karena kita harus memberi nama pada setiap frame data perantara, meskipun kita tidak peduli dengan hal itu. Memberi nama itu sulit, jadi ini memperlambat analisis kita.

Ada cara lain untuk mengatasi masalah yang sama dengan pipa, %>%:

```{r}
delays <- flights %>%
  group_by(dest) %>%
  summarise(count = n(),
            dist = mean(distance, na.rm = TRUE),
            delay = mean(arr_delay, na.rm = TRUE)) %>%
  filter(delay > 20, dest != "HNL")
```

Ini berfokus pada transformasi, bukan pada apa yang ditransformasikan, yang membuat kode lebih mudah dibaca. Anda dapat membacanya sebagai serangkaian pernyataan imperatif: kelompokkan, lalu rangkum, lalu saring. Seperti yang disarankan oleh pembacaan ini, cara yang baik untuk mengucapkan %>% saat membaca kode adalah "kemudian".

Di belakang layar, x %>% f(y) berubah menjadi f(x, y), dan x %>% f(y) %>% g(z) berubah menjadi g(f(x, y), z), dan seterusnya. Anda dapat menggunakan pipa untuk menulis ulang beberapa operasi dengan cara yang dapat Anda baca dari kiri ke kanan, dari atas ke bawah. Kita akan sering menggunakan piping mulai sekarang karena ini sangat meningkatkan keterbacaan kode, dan kita akan kembali membahasnya secara lebih rinci dalam pipa.

Bekerja dengan pipa adalah salah satu kriteria utama untuk menjadi bagian dari tidyverse. Satu-satunya pengecualian adalah ggplot2: ditulis sebelum pipa ditemukan. Sayangnya, iterasi berikutnya dari ggplot2, ggvis, yang memang menggunakan pipa, belum siap untuk digunakan.

### 5.6.2 Nilai yang hilang

Anda mungkin bertanya-tanya tentang argumen na.rm yang kita gunakan di atas. Apa yang terjadi jika kita tidak menyetelnya?

```{r}
flights %>%
  group_by(year, month, day) %>%
  summarise(delay = mean(dep_delay)) %>%
  head()
```
Kami mendapatkan banyak nilai yang hilang! Hal ini karena fungsi agregasi mematuhi aturan umum tentang nilai yang hilang: jika ada nilai yang hilang pada inputnya, maka outputnya juga akan berupa nilai yang hilang. Untungnya, semua fungsi agregasi memiliki argumen na.rm yang menghapus nilai yang hilang sebelum komputasi:

```{r}
flights %>%
  group_by(year, month, day) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  head()
```
Dalam kasus ini, di mana nilai yang hilang mewakili penerbangan yang dibatalkan, kita juga dapat mengatasi masalah ini dengan terlebih dahulu menghapus penerbangan yang dibatalkan. Kita akan menyimpan dataset ini agar dapat digunakan kembali di beberapa contoh berikutnya.
```{r}
not_cancelled <- flights %>%
  filter(!is.na(dep_delay), !is.na(arr_delay))

not_cancelled %>% 
  group_by(year, month, day) %>%
  summarise(delay = mean(dep_delay)) %>%
  head()
```
### 5.6.3 Counts

Setiap kali Anda melakukan agregasi apa pun, selalu merupakan ide yang baik untuk menyertakan hitungan (n()), atau hitungan nilai yang tidak hilang (sum(!is.na(x))). Dengan begitu Anda dapat memeriksa bahwa Anda tidak menarik kesimpulan berdasarkan jumlah data yang sangat kecil. Sebagai contoh, mari kita lihat pesawat (diidentifikasi oleh nomor ekornya) yang memiliki rata-rata keterlambatan tertinggi:

```{r}
delays <- not_cancelled %>%
  group_by(tailnum) %>%
  summarise(delay = mean(arr_delay))

ggplot(data = delays, mapping = aes(x = delay))+
  geom_freqpoly(binwidth = 10)
```
Wow, ada beberapa pesawat yang memiliki penundaan rata-rata 5 jam (300 menit)!

Ceritanya sebenarnya sedikit lebih bernuansa. Kita bisa mendapatkan lebih banyak wawasan jika kita menggambar scatterplot jumlah penerbangan vs rata-rata keterlambatan:

```{r}
delays <- not_cancelled %>%
  group_by(tailnum) %>%
  summarise(delay = mean(arr_delay, na.rm = TRUE),
            n = n())

ggplot(data = delays, mapping = aes(x = n, y = delay))+
  geom_point(alpha = 1/10)
```
Tidak mengherankan, ada variasi yang jatuh lebih besar dalam rata-rata keterlambatan ketika ada sedikit penerbangan. Bentuk plot ini sangat khas: setiap kali Anda memplot rata-rata (atau ringkasan lainnya) vs ukuran kelompok, Anda akan melihat bahwa variasinya menurun seiring dengan bertambahnya ukuran sampel.

Ketika melihat plot semacam ini, sering kali berguna untuk menyaring kelompok dengan jumlah pengamatan terkecil, sehingga Anda dapat melihat lebih banyak pola dan lebih sedikit variasi ekstrem dalam kelompok terkecil. Inilah yang dilakukan oleh kode berikut ini, serta menunjukkan kepada Anda sebuah pola yang berguna untuk mengintegrasikan ggplot2 ke dalam aliran dplyr. Agak sedikit menyakitkan karena Anda harus beralih dari %>% ke +, tetapi setelah Anda menguasainya, ini cukup nyaman.

```{r}
delays %>%
  filter(n > 25) %>%
  ggplot(mapping = aes(x = n, y = delay))+
  geom_point(alpha = 1/10)
```
Tips RStudio: pintasan keyboard yang berguna adalah Cmd/Ctrl + Shift + P. Ini akan mengirim ulang bagian yang sebelumnya dikirim dari editor ke konsol. Ini sangat nyaman ketika Anda (misalnya) mengeksplorasi nilai n dalam contoh di atas. Anda mengirim seluruh blok sekali dengan Cmd/Ctrl + Enter, lalu Anda memodifikasi nilai n dan menekan Cmd/Ctrl + Shift + P untuk mengirim ulang blok lengkap.

Ada variasi umum lainnya dari jenis pola ini. Mari kita lihat bagaimana kinerja rata-rata pemukul dalam bisbol terkait dengan berapa kali mereka memukul. Di sini saya menggunakan data dari paket Lahman untuk menghitung rata-rata memukul (jumlah pukulan / jumlah percobaan) dari setiap pemain bisbol liga utama.

Ketika saya memplot keterampilan pemukul (diukur dengan rata-rata batting, ba) terhadap jumlah kesempatan untuk memukul bola (diukur dengan at bat, ab), Anda akan melihat dua pola:

-   Seperti di atas, variasi dalam agregat kami menurun saat kami mendapatkan lebih banyak titik data.

-   Ada korelasi positif antara keterampilan (ba) dan peluang untuk memukul bola (ab). Hal ini karena tim mengontrol siapa yang akan bermain, dan jelas mereka akan memilih pemain terbaik mereka.

```{r}
# Konversikan ke tibble agar dapat dicetak dengan baik
batting <- as_tibble(Lahman::Batting)
batters <- batting %>%
  group_by(playerID) %>%
  summarise(ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
            ab = sum(AB, na.rm = TRUE))

batters %>%
  filter(ab > 100) %>%
  ggplot(mapping = aes(x = ab, y = ba))+
  geom_point()+
  geom_smooth(se = FALSE)
```
Hal ini juga memiliki implikasi penting untuk peringkat. Jika Anda mengurutkan secara naif pada desc(ba), orang-orang dengan rata-rata pemukul terbaik jelas beruntung, bukan terampil:

```{r}
batters %>%
  arrange(desc(ba)) %>%
  head()
```
### 5.6.4 Fungsi summarize/ringkasan yang berguna
Hanya dengan menggunakan means, counts, dan sum dapat membantu Anda, tetapi R menyediakan banyak fungsi ringkasan lain yang berguna:

-   Ukuran lokasi: kita telah menggunakan mean(x), tetapi median(x) juga berguna. Rata-rata adalah jumlah dibagi dengan panjangnya; median adalah nilai di mana 50% dari x berada di atasnya, dan 50% di bawahnya.

Terkadang berguna untuk menggabungkan agregasi dengan subsetting logis. Kita belum membahas tentang subsetting semacam ini, tetapi Anda akan belajar lebih banyak tentang hal ini di subsetting.
```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(avg_delay1 = mean(arr_delay),
            avg_delay2 = mean(arr_delay[arr_delay > 0])) %>%
  head() # rata-rata penundaan positif


```
-   Ukuran penyebaran: sd(x), IQR(x), mad(x). Akar deviasi kuadrat rata-rata, atau deviasi standar sd(x), adalah ukuran standar penyebaran. Rentang interkuartil IQR(x) dan deviasi absolut median mad(x) adalah ekuivalen yang kuat yang mungkin lebih berguna jika Anda memiliki pencilan.
```{r}
# Mengapa jarak ke beberapa tujuan lebih bervariasi daripada yang lain?

not_cancelled %>%
  group_by(dest) %>%
  summarise(distance_sd = sd(distance)) %>%
  arrange(desc(distance_sd)) %>%
  head()
```

-   Ukuran peringkat: min(x), kuantil (x, 0,25), maks(x). Kuantil adalah generalisasi dari median. Sebagai contoh, kuantil(x, 0,25) akan menemukan nilai x yang lebih besar dari 25% nilai, dan kurang dari 75% sisanya.

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(first = min(dep_time),
            last = max(dep_time)) %>%
  head()
```
-   Ukuran posisi: pertama (x), ke-n (x, 2), terakhir (x). Cara kerjanya mirip dengan x[1], x[2], dan x[length(x)], namun Anda dapat menetapkan nilai default jika posisi tersebut tidak ada (misalnya, Anda mencoba mendapatkan elemen ke-3 dari grup yang hanya memiliki dua elemen). Sebagai contoh, kita dapat menemukan keberangkatan pertama dan terakhir untuk setiap hari:

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(first_dep = first(dep_time),
            last_dep = last(dep_time)) %>%
  head()
```
Fungsi-fungsi ini saling melengkapi dengan pemfilteran pada peringkat. Pemfilteran memberi Anda semua variabel, dengan setiap pengamatan dalam baris terpisah:

```{r}
# menggunakan mutate() & filter()
not_cancelled %>%
  group_by(year, month, day) %>%
  mutate(r = min_rank(desc(dep_time))) %>%
  filter(r %in% range(r)) %>% head()
```
-   Menghitung: Anda telah melihat n(), yang tidak membutuhkan argumen, dan mengembalikan ukuran dari grup saat ini. Untuk menghitung jumlah nilai yang tidak hilang, gunakan sum(!is.na(x)). Untuk menghitung jumlah nilai yang berbeda (unik), gunakan n_distinct(x).

```{r}
# Destinasi mana yang memiliki maskapai paling banyak?
not_cancelled %>%
  group_by(dest) %>%
  summarise(carriers = n_distinct(carrier)) %>%
  arrange(desc(carriers)) %>% head()
```
Hitungan sangat berguna sehingga dplyr menyediakan penolong sederhana jika yang Anda inginkan adalah hitungan:

```{r}
not_cancelled %>%
  count(dest) %>% head()
```

Anda dapat memberikan variabel bobot secara opsional. Sebagai contoh, Anda dapat menggunakan ini untuk "menghitung" (menjumlahkan) jumlah total jarak tempuh pesawat:

```{r}
not_cancelled %>%
  count(tailnum, wt = distance) %>% head()
```
Menghitung dan proporsi nilai logika: sum(x > 10), mean(y == 0). Ketika digunakan dengan fungsi numerik, TRUE diubah menjadi 1 dan FALSE menjadi 0. Hal ini membuat sum() dan mean() menjadi sangat berguna: sum(x) memberikan jumlah TRUE dalam x, dan mean(x) memberikan proporsinya.

```{r}
# Berapa banyak penerbangan yang tersisa sebelum jam 5 pagi? (ini biasanya menunjukkan penundaan
# penerbangan dari hari sebelumnya)

not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(n_early = sum(dep_time < 500)) %>% head()
```
```{r}
# Berapa proporsi penerbangan yang ditunda lebih dari satu jam?

not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(hour_prop = mean(arr_delay > 60)) %>%
  head()
```
### 5.6.5 Pengelompokan berdasarkan beberapa variabel

Ketika Anda mengelompokkan berdasarkan beberapa variabel, setiap ringkasan mengupas satu tingkat pengelompokan. Hal ini memudahkan untuk menggulung set data secara progresif:

```{r}
daily <- group_by(flights, year, month, day)

(per_day <- summarise(daily, flights = n())) #%>% head()
```
```{r}
(per_month <- summarise(per_day, flights = sum(flights))) %>% head()
```
```{r}
(per_year <- summarise(per_month, flights = sum(flights)))
```
Berhati-hatilah saat menjumlahkan ringkasan secara progresif: tidak masalah untuk jumlah dan jumlah, tetapi Anda perlu memikirkan tentang pembobotan rata-rata dan varian, dan tidak mungkin melakukannya dengan tepat untuk statistik berbasis peringkat seperti median. Dengan kata lain, jumlah dari jumlah berkelompok adalah jumlah keseluruhan, tetapi median dari median berkelompok bukanlah median keseluruhan.

### 5.6.6 Ungrouping

Jika Anda perlu menghapus pengelompokan, dan kembali ke operasi pada data yang tidak dikelompokkan, gunakan ungroup().

```{r}
daily %>%
  ungroup() %>%
  summarise(flights = n())
```
### 5.6.7 Exercises

1   Curah pendapat setidaknya 5 cara yang berbeda untuk menilai karakteristik penundaan yang umum terjadi pada sekelompok penerbangan. Pertimbangkan skenario berikut:

-   Sebuah penerbangan lebih awal 15 menit dari 50% waktu, dan terlambat 15 menit dari 50% waktu.

-   Sebuah penerbangan selalu terlambat 10 menit.

-   Sebuah penerbangan lebih awal 30 menit dari 50% waktu, dan terlambat 30 menit dari 50% waktu.

-   99% dari waktu penerbangan tepat waktu. 1% dari waktu penerbangan terlambat 2 jam.

-   Mana yang lebih penting: penundaan kedatangan atau penundaan keberangkatan?

























